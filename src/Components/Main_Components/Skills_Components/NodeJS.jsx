import React from 'react';
import AddPostForm from './features/posts/AddPostForm';
import ReduxPosts from './NodeJSComponents/ReduxPosts';
import Counter from './NodeJSComponents/Counter';
import Router from './NodeJSComponents/Router';
import { Provider } from 'react-redux';
import store from './app/store';
import { BrowserRouter } from "react-router-dom";
import './css/NodeJS.css';
function NodeJS(){
  return (
  <div className="skillsmain">
    <h2>Примеры навыков работы с React</h2>
      <p>Данный сайт построен на React. Также для управления тайтлами страниц используется сторонний компонент Helmet.</p>
      <p>Страница будет обновляться, для показа работы со сторонними компонентами React</p>
      <h2>Примеры навыков работы с Redux</h2>
      <Provider store={store}>
      <Counter />
      <div className="explanationText">
      <h3>Применение Redux для работы с постами</h3>
      <p>В примере ниже по нажатию на кнопку "загрузить посты" с помощью fetch происходит запрос данных с сайта <a href="https://jsonplaceholder.typicode.com/">jsonplaceholder</a> для формирования
      постов. Для реализации данной асинхронной операции работы с Redux можно было использовать <b>thunk</b>, как и в случае с счетчиком, т.е. dispatch в качестве аргумента получает не action, а thunk — специальную функцию, которая, благодаря доп. возможностям, встроенными
      в Redux Toolkit, позволяет обработать информацию в store (хранилище) асинхронно. Thunk содержит два аргумента dispatch и getState (получить состояние). В thunk реализуется асинхронная логика, а в аргумент dispatch можно заносить нужный action. Как и в случае с action, dispatch получает thunk не напрямую, а через "функцию-создатель", возравщающую thunk </p>
      <p> В случае с постами для реализации асинхронности используется функция <b>createAsyncThunk</b>. createAsyncThunk принимает два аргумента:</p>
      <ul>
      <li>строка, которая будет использоваться в качестве префикса для сгенерированных типов действий.</li>
      <li>колбэк-функция, в ней реализуется асинхронная логика</li>
      </ul>
      <p>Функция (в примере эта ф-я postsRequest), созданная на основе createAsyncThunk являются thunk, которая возвращает "функции-создатели" с разными actions в зависимости от выполнения колбэк-функции createAsyncThunk: </p>
      <ul>
      <li>в процессе выполнения колбэк-функции: action.type=префикс(первый аргумент createAsyncThunk)+'/pending'</li>
      <li>успешное завершение колбэк-функции: action.type=префикс+'/fulfilled', action.payload=результат выполнения колбэк-функции</li>
      <li>завершение колбэк-функции, закончившееся ошибкой: action.type=префикс+'/rejected', action.error=ошибка</li>
      </ul>
      <p>Чтобы определить редюсеры для actions (функций-создателей actions), которые не были созданы автоматически из имен редюсеров поля redusers слайса, мы должны воспользоваться функцией <b>extraReducers</b> с параметром builder. У объекта
      builder имеется метод addCase, который первым принимает функцию-создатель action, а вторым функцию, которая и будет редьюсером для данного action. Соответствующие  функции-создатели actions привязаны к нашей функции, созданной с помощью createAsyncThunk, как методы объекта с одноименным названием (например, чтобы получить функцию-создатель для action успешной загрузки постов используем postsRequest.fulfilled)</p>
      <p>Для более явного показа процесса загрузки постов в примере создана искусственная задержка в 2 секунды, в течении которой появляется надпись "Загрузка...".</p>
      <p>Удаление постов можно было бы реализвать через Array.filter(), но данный метод в своей основе предполагает перебор массива и, если массив большой, то это негативно скажется на быстродействии сайта. Функция <b>createEntityAdapter</b> предоставляет стандартизированный способ хранения данных в срезе
      в виде объекта &#123;ids: [], entities: &#123;&#125;&#125;, где в ids содержатся значения полей id наших постов (можно переопределить), а в entities сами объекты постов. Также в createEntityAdapter можно передать, в качестве параметра, функцию сортировки для наших постов. createEntityAdapter
       возвращает объект (в примере это postsAdapter), содержащий набор сгенерированных функций-редюсеров для добавления, обновления и удаления элементов из объекта состояния сущности, что очень удобно и не нужно самому писать данные reducers. Например, для удаления конкретного поста используется метод removeOne (postsAdapter.removeOne(id удаляемого поста)),
       для добавления множества постов setMany (postsAdapter.setMany(state, action.payload)), а initialState создает пустой объект &#123;ids: [], entities: &#123;&#125;&#125; для хранения данных, в который можно добавить дополнительные поля (postsAdapter.getInitialState(&#123;status:'', error:''&#125;)) и т.д. За счет методов-редьюсеров обекта, созданного с помощью createEntityAdapter, достигается управления постами без ресурснозатратных способов.</p>
       </div>
      <AddPostForm />
      <ReduxPosts />
      </Provider>
      <h2>Примеры навыков работы с React Router</h2>
      <p> У данного сайта навигация сделана только на принципе работы компонентов React, не используется даже Context. Ниже продемонстрирован упрощенный макет сайта, как если бы навигация работала с помощью React Router.</p>
      <BrowserRouter>
      <Router />
      </BrowserRouter>
      <h2>Примеры навыков работы с Node.js</h2>
        <p>Идет разработка интернет-магазина на Node.js. Как только проект будет закончен, здесь появится ссылка на GitHub</p>

  </div>)
}
export default NodeJS;
